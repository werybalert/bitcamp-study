// 05.31 실습 파일

public class App {
    public static void main(String[] args) {
/*
            int[] no;

        no = new int[5];

        int[] no2;
        no2 = no;

        no[2] = 31;

        System.out.println(no[2]);

//31

 */

        /*

        char c = 100; // 2byte(0 ~ 65535)
        short x1 = c; // char(0 ~ 65535)
//        컴파일 에러 => short(-32768 ~ 32767), 값의 범위가 맞지 않아 컴파일 오류!
//        App.java:117: error: incompatible types: possible lossy conversion from char to short
//        short x1 = c; // char(0 ~ 65535)
//                   ^
//        1 error
*/


        /*
        1.
        byte b = 100; // 1byte
        short s = 32767; // 2byte(-32768 ~ 32767)
        int i = 98765678; // 4byte(약 -21억 ~ +21억)
        long l = 18_2345_3456_4567_5678L; // 8byte(약 -922경 ~ 922경)

        float f;
        double d;

        // 주의!
        // - float의 자릿수가 넘어가는 정수를 저장하는 경우 값이 짤릴 수 있다.
        // - 그럼에도 불구하고 컴파일 오류가 발생하지 않는다.
        // - 그래서 정수 값을 부동소수점 메모리에 저장할 때 특히 주의해야 한다.

        f = b; // byte(1) ==> float(4). 값을 그대로 저장.
        System.out.println(f);

        // 100.0

        f = s; // short(2) ==> float(4). 값을 그대로 저장.
        System.out.println(f);

        // 32767.0


        f = i; // int(4) ==> float(4).
        // 유효자릿수를 넘는 정수는 짤린다.
        System.out.println(f);

//        9.876568E7

        f = l; // long(8) ==> float(4)
        // 유효자릿수를 넘는 정수는 짤린다.
        System.out.println(f);

//      1.82345345E17

        d = i; // int(4) ==> double(8)
        // 유효자릿수 범위의 정수 값이므로 int(32비트) 값을 그대로 저장할 수 있다.
        System.out.println(d);

//         9.8765678E7

        d = l;
        // 유효 범위를 넘어가는 정수인 경우 짤린다.
        // 주의! 컴파일 오류가 발생하지 않는다.
        System.out.println(d);

//        1.8234534564567568E17
*/
/*


//        2.
        byte b = 100;
        short s = 100;
        int i = 98765678;
        long l = 98765678;
        char c = 100;

        float f;
        double d;

        // 정수 변수의 값을 부동소수점 변수에 저장할 때 값이 짤릴 수 있다.
        //
        f = b; // byte(1) ==> float(4). 값을 그대로 저장.
        System.out.println(f);

//        100

        f = s; // short(2) ==> float(4). 값을 그대로 저장.
        System.out.println(f);

//        100

        f = c; // char(2) ==> float(4). 값을 그대로 저장.
        System.out.println(f);

//         100

        f = i; // int(4) ==> float(4).
        // 유효자릿수를 넘는 정수는 짤린다.
        // 주의! 컴파일 오류가 발생하지 않는다.
        System.out.println(f);

//       9.876568E7

        f = l; // long(8) ==> float(4)
        // 유효자릿수를 넘는 정수는 짤린다.
        // 주의! 컴파일 오류가 발생하지 않는다.
        System.out.println(f);

//      9.876568E7

        d = i; // int(4) ==> double(8)
        // 유효자릿수 범위의 정수 값이므로 int(32비트) 값을 그대로 저장할 수 있다.
        System.out.println(d);

//      9.8765678E7

        l = 18_2345_3456_4567_5678L;
        d = l;
        // 유효 범위를 넘어가는 정수인 경우 짤린다.
        // 주의! 컴파일 오류가 발생하지 않는다.
        System.out.println(d);

//        1.82345345645675 _ 68E17 = 퉁치는 범위 확인
 */

        /*

//  3.
        float f = 3.14f;
        double d = 9876.56789;


         int i = f; // 컴파일 오류!
         long l = d; // 컴파일 오류!

        // 부동소수점 메모리의 값을 정수 메모리에 저장할 수 없다.
        // 왜?
        // - 정수 메모리는 소수점 이하의 값을 저장할 수 없기 때문에
        //   자바에서는 부동소수점 값을 정수 메모리에 저장하는 것을 문법에서 막는다!//
//        App.java:152: error: incompatible types: possible lossy conversion from float to int
//        int i = f; // 컴파일 오류!
//                 ^
//        App.java:153: error: incompatible types: possible lossy conversion from double to long
//        long l = d; // 컴파일 오류!
//                  ^

 */
        /*


//  4.
        // 부동소수점 메모리의 값은 정수 메모리에 저장할 수 없기에 명시적 형변환 문법을 사용하면 가능하다.
        // 명시적 형변환은 1. 큰 메모리의 값을 작은 메모리로 변환 할 때 ,2. 부동소수점을 정수로 변환 할 때

// - 문법
//   변수 = (바꾸고자하는타입) 변수 또는 값;

// float ==> int
        float f = 3.14f;
        int i = (int)f;  // 소수점 이하가 제거된다.
        System.out.println(i);

        //      3

        // double ==> long
        double d = 9876.56789;
        long l = (long)d; // 소수점 이하가 제거된다.
        System.out.println(l);

//        9876



         */
/*

//       5.

        byte b = 100;
        short s = 100;
        int i = 100;
        long l = 100;

        // 큰 메모리의 정수 값을 작은 메모리에 저장하는 경우
        // => 컴파일 오류가 발생한다.
        // => 해결책? 명시적 형변환을 해야 한다.

        // 1) 큰 메모리의 값이 작은 메모리에 충분히 들어가는 경우
        // short ==> byte
        byte b2 = (byte)s; // 명시적 형변환
        System.out.println(b2);

        //100


        // int ==> byte
        b2 = (byte)i; // 명시적 형변환
        System.out.println(b2);

        //100

        // long ==> byte
        b2 = (byte)l; // 명시적 형변환
        System.out.println(b2);

        //100

        // 2) 큰 메모리의 값이 작은 메모리에 들어 갈 수 없는 경우
        // => 앞 쪽 바이트의 값이 짤려서 들어간다.
        int i2 = 0b0000_0000_0000_0000_0000_0001_0010_1100; // = 300(10진수)
        b2 = (byte) i2; //
        System.out.println(b2); // 0b0010_1100

        //44


        l = 400_0000_0000L; // 0x00_00_00_09_50_2f_90_00
        i = (int)l; // 큰 메모리의 값이 작은 메모리에 들어가지 못하는 경우
        System.out.println(l); // 앞 쪽 바이트가 짤린다.
        System.out.println(i);
        System.out.println(0x502f9000);

        //40000000000
        //1345294336
        //1345294336

 */
/*
//6.
        // 1) 정수 메모리끼리 형변환이 가능하다.
        // 2) 부동소수점을 정수로 형변환이 가능한다.
        // 3) 형변환 없이 정수는 부동소수점 메모리에 저장할 수 있다.
        // 4) 숫자를 문자 코드로 형변환 가능한다.
        // 그 외에는 형변환 불가!

        // 예) 정수, 부동소수점 ==/==> boolean
            boolean bool;

            bool = (boolean) 1;
            // 컴파일 오류!
//App.java:255: error: incompatible types: int cannot be converted to boolean
//            bool = (boolean) 1; // 컴파일 오류!
//                             ^


//         예) 문자열 ==/==> 정수, 부동소수점, 문자, boolean
            boolean v1 = (boolean) "true"; // 컴파일 오류!

            char v2 = (char) "가"; // 컴파일 오류!

            int v3 = (int) "123"; // 컴파일 오류!

            float v4 = (int) "3.14f"; // 컴파일 오류!


//App.java:258: error: incompatible types: String cannot be converted to boolean
//            boolean v1 = (boolean) "true"; // 컴파일 오류!
//                                   ^
//App.java:259: error: incompatible types: String cannot be converted to char
//            char v2 = (char) "가"; // 컴파일 오류!
//                             ^
//App.java:260: error: incompatible types: String cannot be converted to int
//            int v3 = (int) "123"; // 컴파일 오류!
//                           ^
//App.java:261: error: incompatible types: String cannot be converted to int
//            float v4 = (int) "3.14f"; // 컴파일 오류!
 */


//        7.

/*

        byte b = Byte.valueOf("100");
        //100

        short s = Short.valueOf("32767");
        //32767


        int i1 = Integer.valueOf("2122223333"); // 문자열 ==> int
        //2122223333

        int i2 = Integer.parseInt("2122223333"); // 문자열 ==> int
        //2122223333

        long l = Long.valueOf("9221111222233334444");

//9221111222233334444

        float f1 = Float.valueOf("3.14f");
//3.14

        float f2 = Float.parseFloat("3.14f");
//3.14

        double d = Double.valueOf("9876.54321");
//9876.54321

        boolean bool1 = Boolean.valueOf("TRUE");   // 문자열 ==> boolean
//true

        boolean bool2 = Boolean.parseBoolean("TRUE");   // 문자열 ==> boolean
//true

        char c = "가나다".charAt(1); // => 나
//나


        System.out.println(b);
        System.out.println(s);
        System.out.println(i1);
        System.out.println(i2);
        System.out.println(l);
        System.out.println(f1);
        System.out.println(f2);
        System.out.println(d);
        System.out.println(bool1);
        System.out.println(bool2);
        System.out.println(c);

 */
/*

//8.

        System.out.println(100 + 27);
        System.out.println(100 - 27);
        System.out.println(100 * 27);
        System.out.println(100 / 27); //3.703703703703704 의 값을 정수와 정수의 계산은 정수가 나와야 하기에 소수점 자리는 생략한다~
        System.out.println(100 % 27); // 나눈 나머지

//127
//73
//2700
//3
//19

        // *, /, % 는 +, - 보다 먼저 계산된다.
        System.out.println(2 + 3 * 7); // 3 * 7을 먼저 수행한다.
        System.out.println(3 * 7 + 2); // 3 * 7을 먼저 수행한다.

        // 같은 우선순위에서는 먼저 나온 것을 먼저 계산한다.
        System.out.println(3 * 8 / 2); // 3 * 8을 먼저 계산
        System.out.println(8 / 2 * 3); // 8 / 2를 먼저 계산
        // 같은 우선순위의 연산자는 실행 순서가 바뀌더라도 상관없다.

        // 강제로 실행 순서를 바꾸고 싶다면
        // 괄호()를 묶어라!
        System.out.println((2 + 3) * 7); // = 35
//23
//23
//12
//12
//35

 */
        /*

//9.
        byte b;
        b = 5; // OK!
        b = 6; // OK!
        // - 리터럴 5, 6은 4바이트 정수 값이다.
        // - 정수 리터럴은 기본이 4바이트 크기이지만,
        // - byte 변수에 저장할 수 있다면 허락한다!

        b = 5 + 6; // OK!
        // - 리터럴끼리 산술 연산한 결과도 리터럴로 간주한다.
        // - 그 결과 값이 변수의 범위 내의 값이면 허락한다.

        System.out.println(b);
        // - 이유? 리터럴 값은 컴파일 단계에서 그 값이 얼마인지 확인할 수 있기 때문이다.
        // - 변수의 경우는 컴파일 단계에서 값을 확인할 수 없다.

//        11

        byte x = 5, y = 6, z;
        z = x; // OK!
        z = y; // OK!

//         z = x + y; // 컴파일 오류!
//  App.java:397: error: incompatible types: possible lossy conversion from int to byte

// short도 마찬가지이다.
        short s1 = 5;
        short s2 = 6;
        short s3;
        s3 = s1; // OK!
        s3 = s2; // OK!
        //    s3 = s1 + s2; // 컴파일 오류!

        int s4 = s1 + s2;
        System.out.println(s4);
//      11




// 10.
        // 모든 종류의 데이터에 대해 산술 연산자를 사용할 수 있는 것은 아니다.
        // 데이터 타입에 따라 제공되는 연산자가 다르다.

        System.out.println(5.75 % 0.24);  // OK!
        //    System.out.println(true % false); // boolean 타입에 대해서는 산술 연산자를 사용할 수 없다.
        //    System.out.println(true + true); // 컴파일 오류!

//0.2300000000000002


        System.out.println("Hello," + "world!"); // OK! '+' 연산자는 문자열 연결 용도로 사용된다.
        //    System.out.println("Hello," - "o,"); // 컴파일 오류!
        //    System.out.println("Hello," * 5); // 컴파일 오류!
//Hello,world!


        System.out.println(true && true);
        //    System.out.println(10 && 10); // 컴파일 오류!이다.
//true

 */

/*

//11.ex05 정리문 정리!

        // 연산을 수행한 후 생성된 결과도 피연산자와 같은 타입이다.

        int i = 5;
        int j = 2;
        float r = i / j; // int와 int의 연산 결과는 항상 int이다.
        // 따라서 r 변수에 넣기 전에
        // 이미 결과는 정수 2가 된다.
        // 정수 2를 float 변수에 넣으면
        // 출력할 때 2.0이 된다.
        System.out.println(r);
//2.0


        // 해결책!
        // - 변수에 들어 있는 값을 다른 타입으로 바꿔라.
        //   "형변환(type conversion=type casting)"하라!
        r = (float)i / (float)j; // float / float = float
        // i / j의 값은 2.5가 되고
        // r에 저장되는 것은 2.5이다.
        System.out.println(r);
//2.5

        // 물론 두 개의 정수 값 중 한 개만 float으로 형변환해도 된다.
        // => 연산을 수행할 때 나머지 변수가 암시적 형변환이 이루어지기 때문이다.
        r = i / (float)j;
        System.out.println(r);
//2.5



         */
//12.
        /*

        // int와 int의 연산 결과는 int이다.
        // 다른 타입이 될 수 없다.
        // => 0111 1111 1111 1111 1111 1111 1111 1111 = Integer.MAX_VALUE
        //
        int x = Integer.MAX_VALUE; // 0x7fffffff = 약 +21억
        int y = Integer.MAX_VALUE; // 0x7fffffff = 약 +21억

        int r1 = x + y; // 0x7fffffff + 0x7fffffff = 0xfffffffe = -2
        //   0111 1111 1111 1111 1111 1111 1111 1111(x)
        // + 0111 1111 1111 1111 1111 1111 1111 1111(y)
        // ---------------------------------------------
        //   1111 1111 1111 1111 1111 1111 1111 1110(r1)
        System.out.println(r1); // int(4byte) + int(4byte) = int(4byte)
        // => int와 int의 연산 결과가 int의 범위를 넘어가면
        //    의도한 결과가 나오지 않을 수 있다.

//      -2


        // 그래서 int와 int의 연산 결과를 더 큰 메모리에 담는다면 해결될까?
        long r2 = x + y;  // 0x7fffffff + 0x7fffffff = 0xfffffffe = -2
        System.out.println(r2); // int(4byte) + int(4byte) = int(4byte)

//         -2

        // 해결 안됨!
        // r2의 출력 결과를 보면 42억이 출력되는 것이 아니라 -2가 출력된다.
        // 이유?
        // - int 와 int의 연산 결과는 피연산자와 같은 4바이트 int가 된다.
        // - 그래서 8바이트 long 변수에 저장하기 전에
        // - 이미 그 결과는 int 값으로 -2가 되기 때문에
        // - long 변수의 값이 -2가 된다.

        // 진정한 해결책?
        // - int와 int 연산 결과가 int 크기를 넘어갈 것 같으면
        //   형변환하여 계산하라!
        r2 = (long)x + (long)y;
        System.out.println(r2);

//          4294967294



         */

        /*

//        13.

        float f1 = 987.6543f;
        float f2 = 1.111111f;
        System.out.println(f1);
        System.out.println(f2);

//        987.6543
//        1.111111

        float r1 = f1 + f2;
        // f1과 f2에 들어 있는 값이 유효자릿수라 하더라도
        // 연산 결과가 유효자릿수가 아니라면 값이 잘리거나 반올림 된다.
        // => float과 float의 연산 결과는 float이기 때문이다.
        //      987.6543
        //    +   1.111111
        //   ---------------
        //      988.765411  <=== float의 유효자릿수인 7자리를 넘어간다.
        //      988.7654    <=== 유효자릿수를 넘어가는 수는 짤린다.

        System.out.println(r1);
        // 기대값: 987.6543 + 1.111111 = 988.765411
        // 결과값: 988.7654
        // 결과가 옳지 않게 나온 이유?
        // => float과 float의 연산 결과는 float이다.
        // => 그래서 메모리 크기를 넘어가는 뒤의 11은 짤린다.


//        988.7654


        // 그럼 결과를 담을 변수의 크기를 늘리면 되는가?
        double r2 = f1 + f2;
        System.out.println(r2);
        // 기대값: 988.765411
        // 결과값: 988.765380859375
        // 기대한 결과가 나오지 않은 이유?
        // => float과 float의 연산 결과는 float이다.
        // => double 변수에 저장하기 전에 이미 float 값이 되면서 일부 값이 왜곡되었다.

//        988.765380859375

        // 그런데 r1 변수와 달리 뒤에 이상한 숫자가 많이 붙는 이유는 무엇인가?
        // => IEEE 754의 이진수 변환 문제때문이다.
        // => 4바이트 float 부동소수점을 8바이트 double 부동소수점 변수에 저장할 때
        //    왜곡된 값이 들어 갈 수 있다.
        // => float을 double 변수에 넣을 때 왜곡이 발생하기 때문에
        //    가능한 double 변수로 값을 바꾼 다음에 연산을 수행하라.
        //    더 좋은 것은 처음부터 double 변수를 사용하라!

        // 다음과 같이 처음부터 double 변수를 사용하라!
        double d1 = 987.6543;
        double d2 = 1.111111;
        double r5 = d1 + d2; // = 988.765411
        System.out.println(r5);
        // 그럼에도 실제 출력해보면 맨 뒤에 극한의 작은 수가 붙는다.
        // 이유? IEEE 754 이진수 변환 문제이다. 고민하지 말라!
        // 어떻게 처리할 건데? 맨 뒤에 붙은 극한의 작은 수는 그냥 잘라 버린다.

//        988.7654110000001

         */

        /*


//        14.
        float r1 = 5 / 2 + 3.1f;
        // 계산 순서:
        // r1 = int(5) / int(2) + float(3.1);
        // r1 = int(2) + float(3.1);
        // r1 = float(2.0) + float(3.1)
        // r1 = float(5.1)
        //
        // => 연산 우선 순위에 따라 계산하는 순간에 암시적 형변환이 이루어진다.
        // => 모든 값을 최종 결과 타입으로 바꾸고 계산하지는 않는다.
        System.out.println(r1);

//        5.1


        float r2 = 3.1f + 5 / 2;
        // 계산 순서
        // r2 = float(3.1) + int(5) / int(2)
        // r2 = float(3.1) + int(2)
        // r2 = float(3.1) + float(2.0)
        // r2 = float(5.1)
        System.out.println(r2);

//        5.1

         */
//      15.
/*

        byte b;

        // 4바이트 크기를 갖는 정수 리터럴을 byte 변수에 저장할 수 없다.
        //    b = 259; // 컴파일 오류!

        // 저장하고 싶다면 형변환(type casting)을 명시적으로 지정하라!
        // => 단 메모리에 들어가기에 큰 값이라면 형변환할 때 값이 잘린다.
        b = (byte)259;
        // int(4 byte)  => 0000 0000 0000 0000 0000 0001 0000 0011
        // byte(1 byte) => ---- ---- ---- ---- ---- ---- 0000 0011

        // => 4바이트 중에서 앞의 3바이트가 잘리고 뒤의 1바이트만 b에 저장된다.

        System.out.println(b);

        // 3

 */

        /*

//        16.
        int a = 10;
        int b = 20;

        // 비교의 결과는 true 또는 false이다.
        // 즉 boolean 값이다.
        boolean r1 = a < b; // true

        //    int r2 = a < b; // 컴파일 오류!

        System.out.println(a < b);
        System.out.println(a <= b);
        System.out.println(a > b);
        System.out.println(a >= b);
        System.out.println(a == b);
        System.out.println(a != b);

//        true
//        true
//        false
//        false
//        false
//        true

 */
/*

//        17.
        double d1 = 987.6543;
        double d2 = 1.111111;
        System.out.println((d1 + d2) == 988.765411);
        //false

        // 결과는 false이다.
        // 이유?
        // - 부동소수점 값을 IEEE 754 명세에 따라 2진수로 바꿔 메모리에 담을 때
        //   정규화(소수점 이하의 수를 2진수로 바꾸는) 과정에서
        //   정수로 딱 떨어지지 않는 경우가 있다.
        //   즉 극한의 미세 소수점이 붙을 수 있다.
        // - CPU나 OS, JVM의 문제가 아니다.
        // - IEEE 754 명세에 따라 부동소수점을 처리하는 모든
        //   컴퓨터에서 발생하는 문제이다.
        // - 이런 부동소수점을 계산할 때 기대하는 값과 다른 값이 나올 수 있다.
        // - 또한 연산한 결과를 메모리에 담을 때도 정규화 과정에서
        //   극한의 미세 소수점이 붙을 수 있다.
        System.out.println(d1);
        System.out.println(d2);
        System.out.println(d1 + d2);
//987.6543
//1.111111
//988.7654110000001


        // 987.6543 + 1.111111 = 988.7654110000001
        // => 결과 뒤에 극소수의 값이 붙는다.
        // => 그래서 부동 소수점의 비교를 대충 다루지 말라!
        // 0 10000001000 1110110111010011110000000001101000110110111000101111 (987.6543)
        // 0 01111111111 0001110001110001110001010011111100111001110100011011 (1.111111)
        //
        // 1.1110110111010011110000000001101000110110111000101111
        // 0.0000000010001110001110001110001010011111100111001110
        //---------------------------------------------------------
        // 1.1110111001100001111110001111110011010110011111111101
        //
        // 0 10000001000 1110111001100001111110001111110011010110011111111101
        // 0 10000001000 1110111001100001111110001111110011010110011111111101

        double x = 234.765411;
        double y = 754.0;
        System.out.println((x + y) == 988.765411);

        System.out.println(x);
        System.out.println(y);
        System.out.println(x + y);

//true

//234.765411
//754.0
//988.765411

        // d1 + d2와 달리 x + y의 계산 결과는 뒤에 극소수의 값이 붙지 않는다.
        // 234.765411 + 754.0 = 988.765411
        //
        // 0 10000000110 1101010110000111111000111111001101011001111111110101 (234.765411)
        // 0 10000001000 0111100100000000000000000000000000000000000000000000 (754.0)
        //
        // 0.0111010101100001111110001111110011010110011111111101
        // 1.0111100100000000000000000000000000000000000000000000
        // ------------------------------------------------------
        // 1.1110111001100001111110001111110011010110011111111101

        // 0 10000001000 1110111001100001111110001111110011010110011111111101


        // IEEE 754의 변환 공식에 따라 발생되는 이런 문제를
        // 실무 프로그래밍 할 때 해결하는 방법?

        System.out.println((d1 + d2) == (x + y));
//false

        // 소수점 뒤에 붙은 극소수의 값을 무시하면 된다.
        // => JVM이 자동으로 처리하지 않는다.
        // => 다음과 같이 개발자가 직접 처리해야 한다.
        double EPSILON = 0.00001;
        System.out.println(Math.abs((d1 + d2) - (x + y)) < EPSILON);
//true


//Math.abs = 절대값 변경 = Math 도구에 absolute를 변환하는 코드

*/
/*

//17.
        float f1 = 12.321f;
        float f2 = 1.1f;
        System.out.println((f1 + f2) == 13.421f);
        System.out.println(f1);
        System.out.println(f2);
        System.out.println(f1 + f2);

//        false
//        12.321
//        1.1
//        13.4210005

        // 12.321
        // => 12: 1100
        // => 0.321: 01010010001011010001
        // => 12 + 0.321 = 1100.01010010001011010001
        // => 1.10001010010001011010001 * 2**3
        // => 지수부: 3 + 127 = 130 = 10000010
        // => 가수부: 10001010010001011010001
        // => 0 10000010 10001010010001011010001
        //
        // 1.1
        // => 1: 1
        // => 0.1: 00011001100110011001101
        // => 1 + 0.1 = 1.00011001100110011001101
        // => 1.00011001100110011001101 * 2**0
        // => 지수부: 0 + 127 = 127 = 01111111
        // => 가수부: 00011001100110011001101
        // => 0 01111111 00011001100110011001101
        //
        // 지수가 작은 쪽을 큰 쪽에 맞춘다.
        // => 1.1의 지수가 0이기 때문에 3으로 맞춘다.
        //    1.10001010010001011010001    (12.321)
        //  + 0.00100011001100110011001    (1.1)
        // ----------------------------------------
        //    1.10101101011110001101010
        //
        // => 0 10000010 10101101011110001101010
        //

        System.out.println("----------------------------------");

        float x = 11.221f;
        float y = 2.2f;
        System.out.println((x + y) == 13.421f);
        System.out.println(x);
        System.out.println(y);
        System.out.println(x + y);
//                ----------------------------------
//        true
//        11.221
//        2.2
//        13.421


        // 11.221
        // => 11: 1011
        // => 0.221: 00111000100100110111
        // => 11 + 0.221 = 1011.00111000100100110111
        // => 1.01100111000100100110111 * 2**3
        // => 지수부: 3 + 127 = 130 = 10000010
        // => 가수부: 01100111000100100110111
        // => 0 10000010 01100111000100100110111
        //
        // 2.2
        // => 2: 10
        // => 0.2: 0011001100110011001101
        // => 2 + 0.2 = 10.0011001100110011001101
        // => 1.00011001100110011001101 * 2**1
        // => 지수부: 1 + 127 = 128 = 10000000
        // => 가수부: 00011001100110011001101
        // => 0 10000000 00011001100110011001101
        //
        // 지수가 작은 쪽을 큰 쪽에 맞춘다.
        // => 2.2의 지수가 1이기 때문에 3으로 맞춘다.
        //    1.01100111000100100110111   (11.221)
        //  + 0.01000110011001100110011 (2.2)
        // ----------------------------------------
        //    1.10101101011110001101010
        //
        // => 0 10000010 10101101011110001101010
        //



 */
/*

//        18.
        // AND 연산자
        // - 두 개의 논리 값이 모두 true일 때 결과가 true가 된다.
        System.out.println(true && true);
        System.out.println(true && false);
        System.out.println(false && true);
        System.out.println(false && false);
//        true
//        false
//        false
//        false

        System.out.println("-----------------------");

        // OR 연산자
        // - 두 개의 논리 값 중 한 개라도 true이면 결과는 true가 된다.
        System.out.println(true || true);
        System.out.println(true || false);
        System.out.println(false || true);
        System.out.println(false || false);

//        true
//        true
//        true
//        false


        System.out.println("-----------------------");

        // NOT 연산자
        // - true는 false로 false는 true로 바꾼다.
        System.out.println(!true);
        System.out.println(!false);

//        false
//        true


        System.out.println("-----------------------");

        // exclusive-OR(XOR)연산자
        // - 배타적 비교 연산자라 부른다.
        // - 두 개의 값이 다를 때 true이다.
        System.out.println(true ^ true);
        System.out.println(false ^ false);
        System.out.println(true ^ false);

//        false
//        false
//        true



//        19.

        // boolean 타입이 아닌 데이터 타입에 대해서는 사용할 수 없다.
            System.out.println(0 && 1); // 컴파일 오류!
//        App.java:899: error: bad operand types for binary operator '&&'
//        System.out.println(0 && 1); // 컴파일 오류!
//                                 ^

            System.out.println(0 || 1); // 컴파일 오류!
//        first type:  int
//        second type: int
//        App.java:900: error: bad operand types for binary operator '||'
//        System.out.println(0 || 1); // 컴파일 오류!


            System.out.println(!0); // 컴파일 오류!
//        first type:  int
//        second type: int
//        App.java:901: error: bad operand type int for unary operator '!'
//        System.out.println(!0); // 컴파일 오류!




        // ^ 연산자를 정수 값에 대해 사용하면
        // 논리 연산자가 아니라 비트 연산자로 동작한다.
        // 비트 연산자인 ^ 은 비트 단위로 연산을 수행한다.
        //
        System.out.println(2 ^ 3);  // OK!

//        1

        // 00000000_00000000_00000000_00000010 (2)
        // 00000000_00000000_00000000_00000011 (3)
        // ---------------------------------------
        // 00000000_00000000_00000000_00000001 (1)

 */

/*

//20.
        // AND 연산자
        // - 두 개의 논리 값이 모두 true일 때 결과가 true가 된다.
        System.out.println(true & true);
        System.out.println(true & false);
        System.out.println(false & true);
        System.out.println(false & false);

//        true
//        false
//        false
//        false
//

        System.out.println("-----------------------");

        // OR 연산자
        // - 두 개의 논리 값 중 한 개라도 true이면 결과는 true가 된다.
        System.out.println(true | true);
        System.out.println(true | false);
        System.out.println(false | true);
        System.out.println(false | false);
//        true
//        true
//        true
//        false

 */

        /*

//        21.
        boolean a = false;
        boolean b = false;
        boolean r = a && (b = true);
        // 계산 순서
        // r = a && (b = true)
        // r = false && (b = true)
        // => && 연산에서 왼쪽 값이 이미 false이기 때문에 결과는 확정되었다.
        // => 이렇게 && 연산의 오른쪽을 실행하기 전에 결과를 알 수 있다면
        //    JVM은 실행의 효율을 위해 && 연산의 오른쪽을 실행하지 않는다.
        // => 그래서 (b = true) 문장은 실행되지 않는다.
        // r = false
        System.out.printf("a=%b, b=%b, r=%b\n", a, b, r);

        //        a=false, b=false, r=false


        a = false;
        b = false;
        r = a & (b = true);
        // 계산 순서
        // r = a & (b = true)
        // r = false & (b = true)
        // => & 연산자의 경우 왼쪽 값으로 결과를 예측할 수 있다 하더라도,
        //    결과에 상관없이 & 오른쪽 문장을 무조건 실행한다.
        // r = false & (b 변수의 값을 true 바꾸고, b 변수의 값을 이 자리에 놓는다.)
        // r = false & true
        // r = false
        System.out.printf("a=%b, b=%b, r=%b\n", a, b, r);


        //        a=false, b=true, r=false


        */
/*

//        22.
        boolean a = true;
        boolean b = false;
        boolean r = a || (b = true);
        // 계산 순서:
        // r = a || (b = true)
        // r = true || (b = true)
        // => || 왼쪽 값으로 이미 결과를 알 수 있기 때문에
        //    || 오른쪽 문장은 실행하지 않는다.
        // r = true
        System.out.printf("a=%b, b=%b, r=%b\n", a, b, r);

        // a=true, b=false, r=true

        a = true;
        b = false;
        r = a | (b = true);
        // 계산 순서:
        // r = a | (b = true)
        // r = true | (b = true)
        // => | 왼쪽 값으로 결과를 확정할 수 있더라도 무조건 오른쪽 문장을 실행한다.
        // r = true | (b 변수에 true를 저장)
        // r = true | true
        // r = true
        System.out.printf("a=%b, b=%b, r=%b\n", a, b, r);


        // a=true, b=true, r=true

 */
        /*

//      23.
        int a = 0b0110_1100;
        int b = 0b0101_0101;

        // 정수 값에 대해서는 &&와 ||, !을 사용할 수 없다.
        System.out.println(a && b); // 컴파일 오류!
        System.out.println(a || b); // 컴파일 오류!
        System.out.println(!a); // 컴파일 오류!

//        App.java:1041: error: bad operand types for binary operator '&&'
//        System.out.println(a && b); // 컴파일 오류!
//                             ^
//  first type:  int
//  second type: int

//App.java:1042: error: bad operand types for binary operator '||'
//        System.out.println(a || b); // 컴파일 오류!
//                             ^
//  first type:  int
//  second type: int

//App.java:1043: error: bad operand type int for unary operator '!'
//        System.out.println(!a); // 컴파일 오류!
//                           ^


        // 그러나 &, |, ^, ~는 사용할 수 있다.
        // => 각 비트 단위로 연산을 수행한다.
        // => 1은 true, 0은 false라고 간주하고 계산한다.
        // => 출력 결과도 정수이다.

        System.out.println(a & b);
        // a = 0000 0000 0000 0000 0000 0000 0110 1100
        // b = 0000 0000 0000 0000 0000 0000 0101 0101
        // --------------------------------------------
        //     0000 0000 0000 0000 0000 0000 0100 0100 = 68

        //68

        System.out.println(a | b);
        // a = 0000 0000 0000 0000 0000 0000 0110 1100
        // b = 0000 0000 0000 0000 0000 0000 0101 0101
        // --------------------------------------------
        //     0000 0000 0000 0000 0000 0000 0111 1101 = 125
//125

        System.out.println(a ^ b);
        // a = 0000 0000 0000 0000 0000 0000 0110 1100
        // b = 0000 0000 0000 0000 0000 0000 0101 0101
        // --------------------------------------------
        //     0000 0000 0000 0000 0000 0000 0011 1001 = 57

        //57

        // 비트 연산에서 not은 ! 연산자가 아니라 ~ 연산자 이다.
        System.out.println(~a);
        // a = 0000 0000 0000 0000 0000 0000 0110 1100
        // --------------------------------------------
        //     1111 1111 1111 1111 1111 1111 1001 0011 = -109

//-109


         */
/*

//        24.

        System.out.println(54 % 2);
        System.out.println(54 & 0b0000_0001);
        System.out.println(54 & 1);

//0
//0
//0

        // % 연산은 나누기 연산을 수행해야 한다.
        // 나누기 연산은 여러 번의 계산을 수행하게 된다.
        // 그에 비해 & 비트 연산은 한 번만 하면 된다.
        // 결론?
        // - 짝수인지 홀수 인지 알아내거나
        // - 2의 나머지를 구하고 싶다면 & 비트 연산을 수행하는 것이 빠르다.
        //
        // 어떤 값에 대해 2로 나눈 나머지 값을 구하고 싶다면,
        // & 연산자를 이용하여 그 값의 하위 1비트 값만 추출하면 된다.
        // 예)
        //    0011 0110 (54)
        //  & 0000 0001 (뒤의 1비트의 값을 추출)
        // --------------
        //    0000 0000 추출된 값은 0이다. 즉 나머지가 없다.
        //
        //    0011 0101 (53)
        //  & 0000 0001
        // --------------
        //    0000 0001 (나머지는 1이다)
        System.out.println("--------------------");


        System.out.println(57 % 4);
        System.out.println(57 & 0b11);
//1
//1


        // 어떤 값에 대해 4로 나눈 나머지 값을 구하고 싶다면,
        // & 연산자를 이용하여 그 값의 하위 2비트 값만 추출하면 된다.
        // 주의!
        // => & 연산자를 사용해서 나머지 값을 구하려면
        //    나누는 값이 2의 제곱수여야 한다.
        // => 즉 2의 제곱수로 나눈 나머지 값을 구하는 경우에는
        //    % 대신 비트 연산자 &를 사용하면 계산 속도가 빠르다.
        // 권고
        // => 너무 고민 말고 그냥 % 사용하라.
        // => 다른 개발자가 이해하기 편할 것이다.
        // => 그럼에도 불구하고 이 연산자의 응용법을 익히는 이유는
        //    가끔 오픈소스나 고급 개발자의 코드에서
        //    이런 코드를 만나기 때문이다.

        System.out.println(57 % 8);
        System.out.println(57 & 0b111); // 57 & 7

        System.out.println(57 % 16);
        System.out.println(57 & 0b1111); // 57 & 15 = 57 & 0xf

//1
//1
//9
//9

//        24.
        // % 연산자를 이용하여 짝수/홀수 알아내기
        System.out.println(57 % 2 == 0 ? "짝수" : "홀수");
//        홀수


        // & 연산자를 이용하여 짝수/홀수 알아내기
        System.out.println((57 & 0x1) == 0 ? "짝수" : "홀수");

//        홀수


//        25.
        int data = 0b1111_1001_0111_1111;
        System.out.println(Integer.toBinaryString(data & 0b0000_1111_1100_0000));

        //   1111_1001_0111_1111
        // & 0000_1111_1100_0000
        //-----------------------
        //   0000_1001_0100_0000

//        100101000000

//        25-1
        // &&, ||, ! 의 피연산자(operand)는 반드시 boolean 이어야 한다.
        // 그리고 계산 결과는 boolean이다.
        boolean r;
            r = 10 && 20; // 컴파일 오류!
            r = 10 || 20; // 컴파일 오류!

        // &, |, ^, ~(not) 의 피연산자가 정수라면
        // 비트 연산자로 동작한다.

            r = 10 & 20; // 컴파일 오류! 비트 연산의 결과는 정수이다.

        int r2 = 10 & 20; // OK!

            float r3 = 10.2f & 20.3f; // 컴파일 오류!

//App.java:1193: error: bad operand types for binary operator '&&'
//            r = 10 && 20; // 컴파일 오류!
//                   ^
//  first type:  int
//  second type: int
//App.java:1194: error: bad operand types for binary operator '||'
//            r = 10 || 20; // 컴파일 오류!
//                   ^
//  first type:  int
//  second type: int
//App.java:1199: error: incompatible types: int cannot be converted to boolean
//            r = 10 & 20; // 컴파일 오류! 비트 연산의 결과는 정수이다.
//                   ^
//App.java:1203: error: bad operand types for binary operator '&'
//            float r3 = 10.2f & 20.3f; // 컴파일 오류!
//                             ^
//  first type:  float
//  second type: float
//4 errors



//        26.

        int pixel = 0x003f4478; // 각 바이트의 값이 '00RRGGBB' 이라 가정하다.
        System.out.println(pixel & 0x0000ffff);
        // pixel = 00000000_00111111_01000100_01111000
        //       & 00000000_00000000_11111111_11111111
        //         00000000_00000000_01000100_01111000

//         17528

//        27.
        int pixel1 = 0x003f4478; // 각 바이트의 값이 '00RRGGBB' 이라 가정하다.
        System.out.println(pixel1 | 0x00000057);
        // pixel = 00000000_00111111_01000100_01111000
        //       | 00000000_00000000_00000000_01010111
        //         00000000_00111111_01000100_01111111

//        4146303

// &연산 | 얀신은 사진작업에서 많이 사용한다.


         */
        /*


//        28.
        // << 비트 이동 연산자 사용법
        // - 왼쪽으로 비트를 이동시킨다.
        // - 오른 쪽 빈자리는 0으로 채운다.
        // - 왼쪽 경계를 넘어간 비트는 자른다.
        //
        int i = 1;
        //      [00000000000000000000000000000001] = 1

        System.out.println(i << 1);
        //     0[0000000000000000000000000000001 ]
        //      [00000000000000000000000000000010] = 2

        System.out.println(i << 2);
        //    00[000000000000000000000000000001  ]
        //      [00000000000000000000000000000100] = 4

        System.out.println(i << 3);
        //   000[00000000000000000000000000001   ]
        //      [00000000000000000000000000001000] = 8

        System.out.println(i << 4);
        //  0000[0000000000000000000000000001    ]
        //      [00000000000000000000000000010000] = 16

        i = 11; // [00000000000000000000000000001011]
        System.out.println(i << 1); //   0[00000000000000000000000000010110] => 22
        System.out.println(i << 2); //  00[00000000000000000000000000101100] => 44
        System.out.println(i << 3); // 000[00000000000000000000000001011000] => 88

        // 왼쪽 이동
        // - 1비트 이동은 곱하기 2 한 것과 같은 효과를 준다.
        // - 값을 배수로 증가시킬 때 곱하기 연산을 하는 것 보다
        //   왼쪽 비트 이동 연산을 하는 것이 빠르기 때문에
        //   실무에서는 이 비트 이동 연산을 자주 사용한다.
        // - 비트 이동 => '2**이동비트'를 곱한 것과 같은 결과를 만든다.

//        29.
        // 0111 1111 1111 1111 1111 1111 1111 1010 =  21_4748_3642
        // 1000 0000 0000 0000 0000 0000 0000 0110 = -21_4748_3642

        // 음수를 왼쪽으로 이동할 때는 부호비트에 상관없이 무조건 이동
        int a = -0x7f_ff_ff_fa; // -21_4748_3642
        System.out.println(a);      //     [10000000000000000000000000000110]
        System.out.println(a << 1); //    1[00000000000000000000000000001100] = 12
        System.out.println(a << 2); //   10[00000000000000000000000000011000] = 24
        System.out.println(a << 3); //  100[00000000000000000000000000110000] = 48
        System.out.println(a << 4); // 1000[00000000000000000000000001100000] = 96

//        30.
        System.out.println(3 << 1);
        //     000000000 00000000 00000000 00000011 = 3
        //   0|000000000 00000000 00000000 00000011x = 비트이동
        //     000000000 00000000 00000000 000000110 = 6

        System.out.println(3 << 33); // 6
        System.out.println(3 << 65); // 6
        System.out.println(3 << 97); // 6

        // 값 3 에 대해 33비트를 이동하나, 65비트를 이동하나, 97 비트를 이동하나
        // 같은 값이 나오는 이유?
        // => int 타입의 값에 대해 비트 이동을 할 때는 0 ~ 31까지만 유효하다.
        //    만약 31을 넘는 경우 32로 나눈 나머지 값을 비트 이동으로 간주한다.
        // => long 타입의 경우 비트 이동은 0 ~ 63까지 유효하다.
        //    만약 63을 넘는 경우 64로 나눈 나머지 값을 비트 이동으로 간주한다.
        //
        // => 공식:
        //    n << s
        //    - n 이 int 타입이라면, 다음 계산을 통해 s의 최종 값을 결정한다.
        //         s % 데이터 타입 비트수 = 최종 비트이동 개수
        //         예1) 3 << 33 = 3 << (33 % 32) = 3 << 1 = 6
        //         예2) 3 << 65 = 3 << (65 % 32) = 3 << 1 = 6
        //         예3) 3 << 97 = 3 << (97 % 32) = 3 << 1 = 6
        //      나머지 값을 계산할 때 % 대신에 비트 연산자 & 를 사용하면 계산 속도가 빠르다.
        //         s & (데이터 타입 비트수 - 1) = 최종 비트 이동 값
        //         예1) 3 << 33
        //              = 3 << (33 & (32 - 1))
        //              = 3 << (33 & 31)
        //              = 3 << (33 & 00011111)
        //                     00100001
        //                    &00011111
        //                   ----------
        //                     00000001 = 1
        //              = 3 << 1 = 6
        //      따라서 s의 값은 무조건 0 ~ 31 이다.
        //      결국 s의 값은 s % 32 의 결과와 같다.
        //
        //    - n 이 long 타입이라면, 다음 계산을 통해 s의 최종 값을 결정한다.
        //         s & 0b111111 = 최종 비트 이동 값
        //      따라서 s의 값은 무조건 0 ~ 63 이다.
        //      결국 s의 값은 s % 64 의 결과와 같다.
        //
        // => 예1)
        //    3 << 33
        //    n => 00000000 00000000 00000000 00000011 = 3
        //    s => 00000000 00000000 00000000 00100001 = 33
        //    비트이동 => s & 0b11111
        //         00000000 00000000 00000000 00100001 = 33
        //       & 00000000 00000000 00000000 00011111
        //       ---------------------------------------
        //         00000000 00000000 00000000 00000001 = 1
        //    최종 비트 이동 값을 계산하면 다음과 같다.
        //      3 << 33 ==> 3 << 1
        //
        // => 예2)
        //    3 << 65
        //    n => 00000000 00000000 00000000 00000011 = 3
        //    s => 00000000 00000000 00000000 01000001 = 65
        //    비트이동 => s & 0b111111
        //         00000000 00000000 00000000 01000001 = 65
        //       & 00000000 00000000 00000000 00111111
        //       ---------------------------------------
        //         00000000 00000000 00000000 00000001 = 1
        //  최종 비트 이동 값을 계산하면 다음과 같다.
        //      3 << 65 ==> 3 << 1
     */
        /*

//        31.
        // >> 비트 이동 연산자 사용법
        // - 왼쪽 쪽 빈자리를 원래 숫자와 같은 부호 값으로 채운다.
        // - 양수라면 0, 음수라면 1을 채운다.
        // - 오른쪽 경계를 넘어간 비트는 자른다.
        //
        int i = 105; // [00000000000000000000000001101001]

        System.out.println(i); //                   => 105

        System.out.println(i >> 1);
        // [ 0000000000000000000000000110100]1
        // [00000000000000000000000000110100]       => 52

        System.out.println(i >> 2);
        // [  000000000000000000000000011010]01
        // [00000000000000000000000000011010]       => 26

        System.out.println(i >> 3);
        // [   00000000000000000000000001101]001
        // [00000000000000000000000000001101]       => 13

        System.out.println(i >> 4);
        // [    0000000000000000000000000110]1001
        // [00000000000000000000000000000110]       => 6


        // 오른쪽 이동
        // - 1비트 이동은 나누기 2 한 것과 같은 효과를 준다.
        // - 예) n에 대해 x비트를 오른쪽으로 이동 = n / 2**x
        // - 소수점이 있는 경우 그 수 보다 작은 바로 밑 정수 값이 된다.
        // - 나누기 연산을 수행하는 것 보다 계산 속도가 빠르다.
        //   실무에서는 나눗셈 연산이 비용(시간과 CPU 사용량)이 많이 들기 때문에
        //   소수점 이하까지 정확하게 계산할 게 아니라면
        //   오른쪽 비트 이동 연산자를 사용하여 주로 처리한다.
        //
//        32.
        // 음수일 경우,
        // - 빈자리는 1로 채운다.
        //
        int i = -87; // [11111111111111111111111110101001]

        System.out.println(i); //                   => -87

        System.out.println(i >> 1);
        // [ 1111111111111111111111111010100]1
        // [11111111111111111111111111010100]1      => -44

        System.out.println(i >> 2);
        // [  111111111111111111111111101010]01
        // [11111111111111111111111111101010]01     => -22

        System.out.println(i >> 3);
        // [   11111111111111111111111110101]001
        // [11111111111111111111111111110101]001    => -11

        System.out.println(i >> 4);
        // [    1111111111111111111111111010]1001
        // [11111111111111111111111111111010]1001    => -6

        // 음수 값에 대해 오른쪽으로 비트 이동
        // => 2**n으로 나눈 것과 같다.
        // => 소수점이 있을 경우 그 수 보다 바로 밑 정수 값이 결과이다.
        // => 왼쪽 빈자리가 부호비트로 채워진다.
         */
     /*

//        33.
        // >>> 비트 이동 연산자 사용법
        // - 오른쪽으로 비트를 이동시킨다.
        // - 왼쪽 빈자리를 음수 양수 상관없이 무조건 0으로 채운다.
        // - 오른쪽 경계를 넘어간 비트는 자른다.
        //
        int i2 = 105; // [00000000000000000000000001101001]

        System.out.println(i2); //                       => 105


        System.out.println(i2 >>> 1);
        // [ 0000000000000000000000000110100]1
        // [00000000000000000000000000110100]1          => 52

        System.out.println(i2 >>> 2);
        // [  000000000000000000000000011010]01
        // [00000000000000000000000000011010]01         => 26

        System.out.println(i2 >>> 3);
        // [   00000000000000000000000001101]001
        // [00000000000000000000000000001101]001        => 13

        System.out.println(i2 >>> 4);
        // [    0000000000000000000000000110]1001
        // [00000000000000000000000000000110]1001       => 6

//        105
//        52
//        26
//        13
//        6


*/

//        34.
        // 음수를 이동:
        // - 왼쪽 빈자리는 0으로 채운다.
        //

        int i2 = -87; // [11111111111111111111111110101001]

        System.out.println(i2);

//  -87

        System.out.println(i2 >>> 1);
        // [ 1111111111111111111111111010100]1
        // [01111111111111111111111111010100]1      => 2147483604

//2147483604

        System.out.println(i2 >>> 2);
        // [  111111111111111111111111101010]01
        // [00111111111111111111111111101010]01     => 1073741802

//1073741802

        System.out.println(i2 >>> 3);
        // [   11111111111111111111111110101]001
        // [00011111111111111111111111110101]001     => 536870901

        //536870901


        System.out.println(i2 >>> 4);
        // [    1111111111111111111111111010]1001
        // [00001111111111111111111111111010]1001     => 268435450

        //268435450


//        35.

        // i 변수에 들어있는 값을 순서대로 1바이트씩 잘라서
        // a,b,c,d 변수에 넣은 다음 각 변수의 값을 16진수로 출력하라!
        int i4 = 0x27a130ff;
        int a, b, c, d;

        System.out.println(i4);
        System.out.println(Integer.toHexString(i4));
//664875263
//27a130ff


        // [00100111_10100001_00110000_11111111] => 27a130ff

        a = i4 >> 24;
        // [00000000_00000000_00000000_00100111]_10100001_00110000_11111111

        b = i4 >> 16 & 0xff;
        //  [00100111_10100001_00110000_11111111] => 27a130ff
        //  [00000000_00000000_00100111_10100001]_00110000_11111111
        //   00000000_00000000_00100111_10100001  => 0x000027a1
        // & 00000000_00000000_00000000_11111111  => 0x000000ff
        // --------------------------------------
        //   00000000_00000000_00000000_10100001

        c = i4 >> 8 & 0xff;
        //  [00100111_10100001_00110000_11111111] => 27a130ff
        //  [00000000_00100111_10100001_00110000]_11111111
        //   00000000_00100111_10100001_00110000  => 0x0027a130
        // & 00000000_00000000_00000000_11111111  => 0x000000ff
        // --------------------------------------
        //   00000000_00000000_00000000_00110000

        d = i4 & 0xff;
        //  [00100111_10100001_00110000_11111111] => 27a130ff
        //  [00100111_10100001_00110000_11111111]
        //   00100111_10100001_00110000_11111111  => 0x27a130ff
        // & 00000000_00000000_00000000_11111111  => 0x000000ff
        // --------------------------------------
        //   00000000_00000000_00000000_11111111

        System.out.println(Integer.toHexString(a));
        System.out.println(Integer.toHexString(b));
        System.out.println(Integer.toHexString(c));
        System.out.println(Integer.toHexString(d));

//        27
//        a1
//        30
//        ff


    }
}


